/**
 * \file
 * \copyright
 * Copyright (c) 2012-2024, OpenGeoSys Community (http://www.opengeosys.org)
 *            Distributed under a Modified BSD License.
 *              See accompanying file LICENSE.txt or
 *              http://www.opengeosys.org/project/license
 *
 */

#include <gtest/gtest.h>

#include <autocheck/autocheck.hpp>

#include "ProcessLib/Output/OutputDataSpecification.h"

namespace ac = autocheck;

class ProcessLibOutputDataSpecification : public ::testing::Test
{
public:
    ProcessLibOutputDataSpecification() {}

    void SetUp() override
    {
        double_classifier.trivial(
            [](const std::vector<double>& fixed_output_times)
            { return fixed_output_times.empty(); });
        double_classifier.collect(
            [](const std::vector<double>& fixed_output_times)
            {
                return fixed_output_times.size() == 1
                           ? "of test cases with one fixed output time step"
                           : "of test cases with more than one fixed output "
                             "time steps";
            });

        pair_classifier.trivial(
            [](const std::vector<ProcessLib::PairRepeatEachSteps>& pairs)
            { return pairs.empty(); });
        pair_classifier.collect(
            [](const std::vector<ProcessLib::PairRepeatEachSteps>& pairs)
            {
                return pairs.size() == 1
                           ? "of test cases with one pair of RepeatEachStep"
                           : "of test cases with more than one pair of "
                             "RepeatEachStep";
            });
    }

protected:
    ac::gtest_reporter gtest_reporter;
    ac::classifier<std::vector<double>> double_classifier;
    ac::classifier<std::vector<ProcessLib::PairRepeatEachSteps>>
        pair_classifier;
};

TEST_F(ProcessLibOutputDataSpecification,
       FixedOutputTimesAndEmptyRepeatsEachSteps)
{
    auto test = [](std::vector<double>& fixed_output_times) -> bool
    {
        bool const output_residuals = false;

        ProcessLib::OutputDataSpecification output_data_specification{
            {} /* output_variables */,
            std::vector<double>{fixed_output_times},
            {} /* repeats_each_steps */,
            output_residuals};

        for (auto const fixed_output_time :
             output_data_specification.fixed_output_times)
        {
            if (!output_data_specification.isOutputStep(1, fixed_output_time))
            {
                return false;
            }
        }

        if (fixed_output_times.empty())
        {
            return true;
        }
        // test time generated by random number generator that isn't included
        // into fixed_output_times
        static const auto seed = static_cast<std::mt19937::result_type>(
            std::chrono::system_clock::now().time_since_epoch().count());
        static std::mt19937 generator{seed};
        auto const [min, max] = std::minmax_element(fixed_output_times.begin(),
                                                    fixed_output_times.end());
        static std::uniform_real_distribution<double> distribution(*min, *max);

        for (int i = 0; i < 100; i++)
        {
            auto const random_time = distribution(generator);
            if (std::find(fixed_output_times.begin(), fixed_output_times.end(),
                          random_time) == fixed_output_times.end())
            {
                if (output_data_specification.isOutputStep(1, random_time))
                {
                    return false;
                }
            }
        }
        return true;
    };

    ac::check<std::vector<double>>(
        test, 100, ac::make_arbitrary(ac::ordered_list<double>()),
        gtest_reporter, double_classifier);
}

TEST_F(ProcessLibOutputDataSpecification, UnsortedFixedTimeStepList)
{
    auto test = [](std::vector<double>& unsorted_fixed_output_times) -> bool
    {
        bool const output_residuals = false;

        try
        {
            ProcessLib::OutputDataSpecification output_data_specification{
                {} /* output_variables */,
                std::vector<double>{unsorted_fixed_output_times},
                {} /* repeats_each_steps */,
                output_residuals};
        }
        catch (...)
        {
            // we expect that the construction throws
            return true;
        }
        return false;
    };

    ac::check<std::vector<double>>(
        test, 100,
        ac::make_arbitrary(ac::list_of<double>())
            .discard_if(
                [](std::vector<double> fixed_output_times)
                {
                    return std::is_sorted(cbegin(fixed_output_times),
                                          cend(fixed_output_times));
                }),
        gtest_reporter, double_classifier);
}

struct PairRepeatEachStepsGenerator
{
    using Gen = ac::generator<unsigned>;
    Gen source;
    using result_type = ProcessLib::PairRepeatEachSteps;

    result_type operator()(std::size_t size)
    {
        return ProcessLib::PairRepeatEachSteps{
            static_cast<int>(source(size)), static_cast<int>(source(size)) + 1};
    }
};

struct IllegalPairRepeatEachStepsGenerator
{
    using Gen = ac::generator<unsigned>;
    Gen source;
    using result_type = ProcessLib::PairRepeatEachSteps;

    result_type operator()(std::size_t size)
    {
        return ProcessLib::PairRepeatEachSteps{static_cast<int>(source(size)),
                                               0};
    }
};

TEST_F(ProcessLibOutputDataSpecification, TestIllegalConstructorParameter)
{
    auto test =
        [](std::vector<ProcessLib::PairRepeatEachSteps>& repeats_each_steps)
        -> bool
    {
        bool const output_residuals = false;

        try
        {
            ProcessLib::OutputDataSpecification output_data_specification{
                {} /* output_variables */,
                {} /* fixed_output_times */,
                std::vector<ProcessLib::PairRepeatEachSteps>{
                    repeats_each_steps},
                output_residuals};
        }
        catch (...)
        {
            // we expect that the construction throws
            return true;
        }
        return false;
    };

    auto list_generator = ac::list_of(IllegalPairRepeatEachStepsGenerator());
    auto arb =
        ac::make_arbitrary(list_generator)
            .discard_if([](std::vector<ProcessLib::PairRepeatEachSteps> pairs)
                        { return pairs.empty(); });

    ac::check<std::vector<ProcessLib::PairRepeatEachSteps>>(
        test, 100, arb, gtest_reporter, pair_classifier);
}

TEST_F(ProcessLibOutputDataSpecification,
       EmptyFixedOutputTimesAndRepeatsEachSteps)
{
    auto test =
        [](std::vector<ProcessLib::PairRepeatEachSteps>& repeats_each_steps)
        -> bool
    {
        bool const output_residuals = false;

        ProcessLib::OutputDataSpecification output_data_specification{
            {} /* output_variables */,
            {} /* fixed_output_times */,
            std::vector<ProcessLib::PairRepeatEachSteps>{repeats_each_steps},
            output_residuals};

        for (auto const fixed_output_time :
             output_data_specification.fixed_output_times)
        {
            if (!output_data_specification.isOutputStep(1, fixed_output_time))
            {
                return false;
            }
        }

        int step = 0;
        for (auto const& repeats_each_steps_pair : repeats_each_steps)
        {
            for (int i = 0; i < repeats_each_steps_pair.repeat; ++i)
            {
                step += repeats_each_steps_pair.each_steps;
                if (!output_data_specification.isOutputStep(step, {}))
                {
                    return false;
                }
            }
        }
        return true;
    };

    auto list_generator = ac::list_of(PairRepeatEachStepsGenerator());
    auto arb = ac::make_arbitrary(list_generator);

    ac::check<std::vector<ProcessLib::PairRepeatEachSteps>>(
        test, 100, arb, gtest_reporter, pair_classifier);
}
