# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.16.2
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
#   note: 'TODO: remove after 6.5.4 release: ci skip'
# ---

# %% [raw]
# +++
# title = "Evaluating the B-bar method with simple examples"
# date = "2024-08-29"
# author = "Wenqing Wang"
# image = "figures/quad_M_fig.png"
# web_subsection = "small-deformations"
# weight = 3
# +++

# %% [markdown]
# $$
# \newcommand{\B}{\text{B}}
# \newcommand{\F}{\text{F}}
# \newcommand{\I}{\mathbf I}
# \newcommand{\intD}[1]{\int_{\Omega_e}#1\mathrm{d}\Omega}
# $$
#
# ## Evaluating the B-bar method with simple examples
#
# This is a plane strain example demonstrating the mechanical behavior of a $1\text{m}\times1\text{m}$ domain under a constant pressure of 10 MPa.
#
# We analyze two problems, referred to as the homogeneous and heterogeneous problems.
# The schematics of these problems are shown in the figures below:
#
# Homogeneous problem             |  heterogeneous problem
# :-----------------------------:|:-----------------------------:
# <img src="./figures/quad_M_fig_homo.png" alt="Simple test" width="200" height="200" />  | <img src="./figures/quad_M_fig.png" alt="Simple test" width="200" height="200" />
#
# As can be seen from the schematic figures, the settings of the two problems are identical except for the boundary conditions on the bottom edge.
# For the homogeneous problem, the bottom boundary has a roller support with the horizontal displacement fixed at the lower left corner.
# Under these boundary conditions, the strain and stress remain homogeneous throughout the domain.
# For the heterogeneous problem, all displacement components on the bottom are fixed, leading to heterogeneous strain, and stress within the domain.
#
# Material compressibility is accounted for by using a Poisson's ratio (nu) of 0.2 for the compressible material and 0.499 for the incompressible material.
#
# We also consider the influence of element size on the accuracy of the solutions.
# Therefore, the tests are conducted using different meshes, generated by dividing the domain into a varying number of elements per edge: 2, 10, 15, 20, 25, and 30, respectively.

# %%
import os
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import ogstools as ot

out_dir = Path(os.environ.get("OGS_TESTRUNNER_OUT_DIR", "_out"))
out_dir.mkdir(parents=True, exist_ok=True)


def run(bbar: bool, n: int, homo: bool, nu: float) -> ot.Mesh:
    name = f"{homo=}_{bbar=}_{nu=}".replace("=", "_").lower()
    model = ot.Project(
        input_file="simple_b_bar_test.prj", output_file=out_dir / "modified.prj"
    )
    model.replace_text(str(bbar).lower(), "./processes/process/use_b_bar")
    model.replace_text(name, "./time_loop/output/prefix")
    model.replace_text(2, "./process_variables/process_variable/order")
    if homo:
        model.replace_text("origin", ".//boundary_condition[1]/geometry")
    model.replace_text(str(nu), ".//parameter[name='nu']/value")
    model.replace_text(f"quad_edge_div_{n}.vtu", xpath="./mesh")
    model.write_input()
    model.run_model(logfile=out_dir / "out.txt", args=f"-o {out_dir} -m .")
    return ot.MeshSeries(out_dir / (name + ".pvd"))[-1]


def multi_run(bbar: bool, n: list[int], homo: bool, nu: float) -> list[ot.Mesh]:
    return [run(homo=homo, nu=nu, bbar=bbar, n=n_i) for n_i in n]


def contourplots(
    results: dict[bool, list[ot.Mesh]], var: ot.variables.Variable
) -> plt.Figure:
    fig, axs = plt.subplots(1, 2, figsize=[8, 3], sharey=True)
    for (bbar, meshes), ax in zip(results.items(), axs, strict=True):
        ot.plot.contourf(meshes[-1], var, fig=fig, ax=ax, show_edges=True)
        ax.set_title(f"{bbar=}")
    ot.plot.utils.update_font_sizes(fig.axes, 10)
    return fig


def center_data(meshes: list[ot.Mesh], var: ot.variables.Variable) -> np.ndarray:
    center_ids = [mesh.find_closest_point(mesh.center) for mesh in meshes]
    return np.asarray(
        [var.transform(mesh)[idx] for idx, mesh in zip(center_ids, meshes, strict=True)]
    )


def plot_center_per_refinement(results: dict[bool, list[ot.Mesh]]) -> plt.Figure:
    fig, axs = plt.subplots(1, 3, figsize=(9, 3))
    ax: plt.Axes
    for bbar, meshes in results.items():
        for ax, var in zip(axs, [u["y"], eps["yy"], sig["yy"]], strict=True):
            vals = center_data(meshes, var)
            ax.plot(n_range, vals, ls="-" if bbar else "--", label=f"{bbar=}")
            ax.set_xlabel("Number of elements per side")
            ax.set_ylabel(var.get_label())
            ax.legend()
    fig.tight_layout()
    return fig


def compare_data(results: dict[bool, list[ot.Mesh]], var: ot.variables.Variable):
    for bbar, meshes in results.items():
        vals = var.transform(meshes[-1], strip_unit=False)
        print(f"{var.output_name}, {bbar=}:", end="\t")
        print(f"mean={np.mean(vals):.3g}", end="\t")
        print(f"range of deviation={np.ptp(vals):.3g}")


def compare_with_analytical_solution(
    results: dict[bool, list[ot.Mesh]], nu: float, E: float = 1e10, p: float = -10e6
):
    def eps_ref(nu: float):
        lambd = nu * E / (1 + nu) / (1 - 2.0 * nu)
        G = 0.5 * E / (1 + nu)
        eps_11 = -0.25 * lambd * p / G / (lambd + G)
        eps_22 = eps_11 + 0.5 * p / G
        return [eps_11, eps_22, 0.0, 0.0]

    def u_ref(nu: float):
        eps_ref_val = eps_ref(nu)
        return [0.5 * eps_ref_val[0], 0.5 * eps_ref_val[1]]

    def sigma_ref(nu: float):
        return [0.0, p, nu * p, 0.0]

    def check(a, b, atol):
        np.testing.assert_allclose(a, np.tile(b, (len(a), 1)), 1e-10, atol)

    combinations = [[u, u_ref, 3e-5], [eps, eps_ref, 8e-16], [sig, sigma_ref, 4e-5]]
    for meshes in results.values():
        for var, ref, abstol in combinations:
            num_data = center_data(meshes, var.replace(data_unit=var.output_unit))
            check(num_data, ref(nu), abstol)


def test_center_difference_below(
    results: dict[bool, list[ot.Mesh]],
    var: ot.variables.Variable,
    atols: tuple[float, float],
):
    vals_a, vals_b = (center_data(results[True], var), center_data(results[False], var))
    max_diff = np.geomspace(atols[0], atols[1], len(n_range))
    np.testing.assert_array_less(np.abs(vals_a - vals_b), max_diff)


n_range = [2, 10, 15, 20, 25, 30, 40]
u = ot.variables.displacement.replace(output_unit="mm")
eps = ot.variables.strain
sig = ot.variables.stress


# %% [markdown]
# ### Homogeneous problem
#
# The analytical solutions of the stress components on the plane are $\sigma_{11} = 0$, $\sigma_{22} = -10$ MPa.
# The analytical solutions of the remaining variables are
#
# $$
# \begin{align}
# \sigma_{33} &= \nu(\sigma_{11}+\sigma_{22})\\
# \epsilon_{11} &= \frac{\lambda}{4G(\lambda+G)}\sigma_{22}\\
# \epsilon_{22} &= \epsilon_{11} + \frac{\sigma_{22}}{2G} \\
# u_{1} &= \epsilon_{11}x \\
# u_{2} &= \epsilon_{11}y
# \end{align}
# $$
# with $E$ the Young's modulus, $G=E/2(1+\nu)$ the shear modulus, $\nu$ the Poisson ratio, and $\lambda=E\nu/((1+\nu)(1-2\nu))$ the Lame constant, $u$ the displacement, $\epsilon$ the strain, and $\sigma$ the stress.
#
# #### Compressible material (nu=0.2)

# %%
homogeneous_compressible = {
    bbar: multi_run(bbar, n_range, homo=True, nu=0.2) for bbar in [True, False]
}

# %% [markdown]
# The displacement field is linear and the same in both cases:
#

# %%
fig = contourplots(homogeneous_compressible, u["y"])

# %% [markdown]
# The vertical stress is constant everywhere aside from random noise.

# %%
compare_data(homogeneous_compressible, sig["yy"])

# %% [markdown]
# For this homogeneous problem, the solutions obtained using the B-bar method have almost the same accuracy as those obtained with the standard approach.
# This is confirmed by the following comparisons with the analytical solutions:

# %%
compare_with_analytical_solution(homogeneous_compressible, nu=0.2)

# %% [markdown]
# #### Incompressible material (nu=0.499)

# %%
homogeneous_incompressible = {
    bbar: multi_run(bbar, n_range, homo=True, nu=0.499) for bbar in [True, False]
}

# %% [markdown]
# Again, the displacement field is linear and the same in both cases:

# %%
fig = contourplots(homogeneous_incompressible, u["y"])

# %% [markdown]
# Also the vertical stress is again constant everywhere aside from random noise.

# %%
compare_data(homogeneous_incompressible, sig["yy"])


# %% [markdown]
# The following figure shows the vertical components of displacement, strain and stress at the center over the different discretizations.
# It shows, that this model, with or without the B-bar method, delivers accurate solutions and exhibits excellent mesh size independence.
# This reflects the fact that this test has no volumetric locking though the material is incompressible.

# %%
fig = plot_center_per_refinement(homogeneous_incompressible)

# %%
compare_with_analytical_solution(homogeneous_incompressible, nu=0.499)

# %% [markdown]
# ### Heterogeneous problem
#
# #### Compressible material (nu=0.2)

# %%
heterogeneous_compressible = {
    bbar: multi_run(bbar, n_range, homo=False, nu=0.2) for bbar in [True, False]
}

# %% [markdown]
# In the following figures we see, that with and without the B-bar method, the variable distribution patterns look quite similar.
# In the bottom corners the stresses deviate from each other.
#

# %%
fig = contourplots(heterogeneous_compressible, u["y"])
fig = contourplots(heterogeneous_compressible, sig["yy"])

# %%
test_center_difference_below(heterogeneous_compressible, u["y"], (3e-2, 1e-4))
test_center_difference_below(heterogeneous_compressible, eps["yy"], (1e-2, 1e-5))
test_center_difference_below(heterogeneous_compressible, sig["yy"], (0.7, 1e-3))

# %% [markdown]
# The following figure shows, that the differences in the center between the results with B-Bar and without B-bar tend to become tiny as the mesh refinement level increases.

# %%
fig = plot_center_per_refinement(heterogeneous_compressible)

# %% [markdown]
# #### Incompressible material (nu=0.499)

# %%
heterogeneous_incompressible = {
    bbar: multi_run(bbar, n_range, homo=False, nu=0.499) for bbar in [True, False]
}

# %% [markdown]
# In the following figures we see, that the bottom corners exhibit even stronger stress concentrations, which is slightly reduced by the B-bar method.
#

# %%
fig = contourplots(heterogeneous_incompressible, u["y"])
fig = contourplots(heterogeneous_incompressible, sig["yy"])

# %% [markdown]
# The following figure shows, that the differences in the center between the results with B-Bar and without B-bar tend to become smaller as the mesh refinement level increases, but not as much, as in the compressible model.

# %%
fig = plot_center_per_refinement(heterogeneous_incompressible)

# %%
test_center_difference_below(heterogeneous_incompressible, u["y"], (0.2, 3e-3))
test_center_difference_below(heterogeneous_incompressible, eps["yy"], (2e-2, 3e-4))
test_center_difference_below(heterogeneous_incompressible, sig["yy"], (14, 0.3))

# %% [markdown]
# ## Conclusions
# In the FEM analysis of small deformation problems,
#
# *  The B-bar method can significantly alleviate volumetric locking in incompressible materials with a high-quality mesh.
# *  When applied to problems with compressible materials, the B-bar method can still give accurate solutions with a fine mesh.
# *  The B-bar method may better find the correct solution when the material is highly incompressible and there is volumetric locking.
