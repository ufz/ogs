/**
 * \file
 * \author Thomas Fischer
 * \date   2011-03-08
 * \brief  Implementation of the generateBCFromPolyline tool.
 *
 * \copyright
 * Copyright (c) 2013, OpenGeoSys Community (http://www.opengeosys.org)
 *            Distributed under a Modified BSD License.
 *              See accompanying file LICENSE.txt or
 *              http://www.opengeosys.org/project/license
 *
 */

#include <fstream>

#include <QString>

// GeoLib
#include "GEOObjects.h"
#include "PolylineVec.h"

// OGS
#include "OGS/ProjectData.h"

// FileIO
#include "XmlIO/XmlGmlInterface.h"

int main (int argc, char* argv[])
{
	if (argc == 1)
	{
		std::cout << "Usage: " << argv[0] << " gml-file" << std::endl;
		std::cout << "\tgives you the name of all polylines in the file" << std::endl;
		std::cout << "Usage: " << argv[0] << " gml-file polyline-to-convert" << std::endl;
		std::cout << "\tcreates for the given polyline points boundary conditions" <<
		std::endl;
		return -1;
	}
	GeoLib::GEOObjects* geo_objs (new GeoLib::GEOObjects);
	std::string schema_name(
	        "/home/fischeth/workspace/OGS-FirstFloor/sources/FileIO/OpenGeoSysGLI.xsd");
	ProjectData* project_data (new ProjectData);
	project_data->setGEOObjects (geo_objs);
	FileIO::XmlGmlInterface xml(project_data, schema_name);
	std::string fname (argv[1]);
	xml.readFile(QString::fromStdString (fname));

	std::vector<std::string> geo_names;
	geo_objs->getGeometryNames (geo_names);
	if (geo_names.empty ())
	{
		std::cout << "no geometries found" << std::endl;
		return -1;
	}
	const GeoLib::PolylineVec* ply_vec (geo_objs->getPolylineVecObj(geo_names[0]));
	if (!ply_vec)
	{
		std::cout << "could not found polylines" << std::endl;
		delete project_data;
		return -1;
	}
	const size_t n_ply (ply_vec->size());

	std::vector<size_t> ply_pnt_ids;
	for (size_t k(0); k < n_ply; k++)
	{
		std::string ply_name;
		if (ply_vec->getNameOfElementByID(k, ply_name))
		{
			if (argc == 2)
				std::cout << "polyline " << k << ": " << ply_name << std::endl;
			else if (ply_name.find (argv[2]) != std::string::npos)
			{
				std::cout << "found polyline " << ply_name << std::endl;
				GeoLib::Polyline const* ply (ply_vec->getElementByName(ply_name));
				const size_t n_ply_pnts (ply->getNumberOfPoints());
				for (size_t j(0); j < n_ply_pnts; j++)
					ply_pnt_ids.push_back (ply->getPointID(j));
			}
		}
	}

	if (argc == 2)
		return 0;

	std::vector<GeoLib::Point*> const* geo_pnts (geo_objs->getPointVec(geo_names[0]));
	// write gli file and bc file
	std::ofstream gli_out ("TB.gli");
	std::ofstream bc_out ("TB.bc");
	bc_out << "// file generated by " << argv[0] << "\n";
	if (gli_out && bc_out)
	{
		gli_out << "#POINTS" << "\n";
		for (size_t k(0); k < ply_pnt_ids.size(); k++)
		{
			gli_out << k << " " << *((*geo_pnts)[ply_pnt_ids[k]]) << " $NAME PLYPNT" <<
			argv[2] << k << "\n";
			// boundary condition
			bc_out << "#BOUNDARY_CONDITION" << "\n";
			bc_out << "\t$PCS_TYPE" << "\n" << "\t\tGROUNDWATER_FLOW" << "\n";
			bc_out << "\t$PRIMARY_VARIABLE" << "\n" << "\t\tHEAD" << "\n";
			bc_out << "\t$GEO_TYPE" << "\n" << "\t\tPOINT PLYPNT" << argv[2] <<
			k << "\n";
			bc_out << "\t$DIS_TYPE" << "\n" << "\t\tCONSTANT " <<
			(*((*geo_pnts)[ply_pnt_ids[k]]))[2] << "\n";
		}
		gli_out << "#STOP" << "\n";
		bc_out << "#STOP" << "\n";
		gli_out.close ();
		bc_out.close ();
	}

	delete project_data;
}
