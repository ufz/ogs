From 54683afd1467fc0503f5902e0ed25e16869f3a80 Mon Sep 17 00:00:00 2001
From: David Gobbi <david.gobbi@gmail.com>
Date: Sat, 13 Jul 2013 14:28:06 -0600
Subject: [PATCH] COMP: Fix incorrectly set VTK_HAS_STD_ISFINITE variable.

The check_symbol_exists() macro that we had been using to find
std::isfinite, std::isnan, and std::isnan does not work with
namespaces or overloaded functions.  As a result, the checks
for these functions were failing.  This patch adds a new macro
check_cxx_function_exists() that checks if a C++ function will
compile when given arguments with specific type, for example:
check_cxx_function_exists(std::isnan double cmath HAVE_STD_ISNAN)
When using this macro, if the function has multiple arguments,
then separate them with a semicolon e.g. "char *;int".

Change-Id: I1ef7cd4daa52067badb0928d01c3f8b22953c601
---
 CMake/CheckCXXFunctionExists.cmake |  126 ++++++++++++++++++++++++++++++++++++
 Common/Core/CMakeLists.txt         |    7 +-
 Common/Core/vtkMath.h              |   15 +++-
 3 files changed, 141 insertions(+), 7 deletions(-)
 create mode 100644 CMake/CheckCXXFunctionExists.cmake

diff --git a/CMake/CheckCXXFunctionExists.cmake b/CMake/CheckCXXFunctionExists.cmake
new file mode 100644
index 0000000..205613f
--- /dev/null
+++ b/CMake/CheckCXXFunctionExists.cmake
@@ -0,0 +1,126 @@
+# - Check if a C++ function exists
+# CHECK_CXX_FUNCTION_EXISTS(<function> <argtypes> <files> <variable>)
+#
+# Check that the <function> is available after including given header
+# <files> and store the result in a <variable>.  Specify the list
+# of files in one argument as a semicolon-separated list.
+#
+# The following variables may be set before calling this macro to
+# modify the way the check is run:
+#
+#  CMAKE_REQUIRED_FLAGS = string of compile command line flags
+#  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
+#  CMAKE_REQUIRED_INCLUDES = list of include directories
+#  CMAKE_REQUIRED_LIBRARIES = list of libraries to link
+
+#=============================================================================
+# Copyright 2003-2011 Kitware, Inc.
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+# (To distribute this file outside of CMake, substitute the full
+#  License text for the above reference.)
+
+IF(CMAKE_VERSION VERSION_GREATER "2.8.7")
+  INCLUDE(CMakeExpandImportedTargets)
+ENDIF(CMAKE_VERSION VERSION_GREATER "2.8.7")
+
+MACRO(CHECK_CXX_FUNCTION_EXISTS FUNCTION TYPES FILES VARIABLE)
+  _CHECK_CXX_FUNCTION_EXISTS("${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/CheckSymbolExists.cpp" "${FUNCTION}" "${TYPES}" "${FILES}" "${VARIABLE}" )
+ENDMACRO(CHECK_CXX_FUNCTION_EXISTS)
+
+MACRO(_CHECK_CXX_FUNCTION_EXISTS SOURCEFILE FUNCTION TYPES FILES VARIABLE)
+  IF("${VARIABLE}" MATCHES "^${VARIABLE}$")
+    SET(CMAKE_CONFIGURABLE_FILE_CONTENT "/* */\n")
+    SET(MACRO_CHECK_CXX_FUNCTION_EXISTS_FLAGS ${CMAKE_REQUIRED_FLAGS})
+    IF(CMAKE_REQUIRED_LIBRARIES)
+      IF(CMAKE_VERSION VERSION_GREATER "2.8.7")
+        # translate potentially used imported library targets to their files on disk
+        CMAKE_EXPAND_IMPORTED_TARGETS(_ADJUSTED_CMAKE_REQUIRED_LIBRARIES  LIBRARIES  ${CMAKE_REQUIRED_LIBRARIES} CONFIGURATION "${CMAKE_TRY_COMPILE_CONFIGURATION}")
+        SET(CHECK_CXX_FUNCTION_EXISTS_LIBS
+          "-DLINK_LIBRARIES:STRING=${_ADJUSTED_CMAKE_REQUIRED_LIBRARIES}")
+      ELSE(CMAKE_VERSION)
+        SET(CHECK_CXX_FUNCTION_EXISTS_LIBS
+          "-DLINK_LIBRARIES:STRING=${CMAKE_REQUIRED_LIBRARIES}")
+      ENDIF(CMAKE_VERSION)
+    ELSE(CMAKE_REQUIRED_LIBRARIES)
+      SET(CHECK_CXX_FUNCTION_EXISTS_LIBS)
+    ENDIF(CMAKE_REQUIRED_LIBRARIES)
+    IF(CMAKE_REQUIRED_INCLUDES)
+      SET(CMAKE_FUNCTION_EXISTS_INCLUDES
+        "-DINCLUDE_DIRECTORIES:STRING=${CMAKE_REQUIRED_INCLUDES}")
+    ELSE(CMAKE_REQUIRED_INCLUDES)
+      SET(CMAKE_FUNCTION_EXISTS_INCLUDES)
+    ENDIF(CMAKE_REQUIRED_INCLUDES)
+    FOREACH(FILE ${FILES})
+      SET(CMAKE_CONFIGURABLE_FILE_CONTENT
+        "${CMAKE_CONFIGURABLE_FILE_CONTENT}#include <${FILE}>\n")
+    ENDFOREACH(FILE)
+    SET(CMAKE_CONFIGURABLE_FILE_CONTENT
+      "${CMAKE_CONFIGURABLE_FILE_CONTENT}\nint main(int argc, char *argv[])\n{\n")
+    SET(COUNT 0)
+    FOREACH(TYPE ${TYPES})
+      MATH(EXPR COUNT "${COUNT} + 1")
+      SET(INIT)
+      # avoid warnings by adding initializer
+      SET(NUMERIC char short int long float double "long double" size_t)
+      LIST(FIND NUMERIC "${TYPE}" FOUND)
+      IF(FOUND GREATER -1)
+        SET(INIT " = 0")
+      ENDIF(FOUND GREATER -1)
+      IF(TYPE MATCHES ".*\\*")
+        SET(INIT " = 0")
+      ENDIF(TYPE MATCHES ".*\\*")
+      SET(CMAKE_CONFIGURABLE_FILE_CONTENT
+        "${CMAKE_CONFIGURABLE_FILE_CONTENT}  ${TYPE} arg${COUNT}${INIT};\n")
+    ENDFOREACH(TYPE)
+    SET(CMAKE_CONFIGURABLE_FILE_CONTENT
+      "${CMAKE_CONFIGURABLE_FILE_CONTENT}  (void)argv;\n  (void)argc;\n  ${FUNCTION}(")
+    SET(COUNT 0)
+    SET(COMMA)
+    FOREACH(TYPE ${TYPES})
+      MATH(EXPR COUNT "${COUNT} + 1")
+      SET(CMAKE_CONFIGURABLE_FILE_CONTENT
+        "${CMAKE_CONFIGURABLE_FILE_CONTENT}${COMMA}arg${COUNT}")
+      SET(COMMA ", ")
+    ENDFOREACH(TYPE)
+    SET(CMAKE_CONFIGURABLE_FILE_CONTENT
+      "${CMAKE_CONFIGURABLE_FILE_CONTENT});\n  return 0;\n}\n")
+
+    CONFIGURE_FILE("${CMAKE_ROOT}/Modules/CMakeConfigurableFile.in"
+      "${SOURCEFILE}" @ONLY IMMEDIATE)
+
+    MESSAGE(STATUS "Looking for ${FUNCTION}")
+    TRY_COMPILE(${VARIABLE}
+      ${CMAKE_BINARY_DIR}
+      "${SOURCEFILE}"
+      COMPILE_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}
+      CMAKE_FLAGS
+      -DCOMPILE_DEFINITIONS:STRING=${MACRO_CHECK_CXX_FUNCTION_EXISTS_FLAGS}
+      "${CHECK_CXX_FUNCTION_EXISTS_LIBS}"
+      "${CMAKE_FUNCTION_EXISTS_INCLUDES}"
+      OUTPUT_VARIABLE OUTPUT)
+    IF(${VARIABLE})
+      MESSAGE(STATUS "Looking for ${FUNCTION} - found")
+      SET(${VARIABLE} 1 CACHE INTERNAL "Have function ${FUNCTION} ${TYPES}")
+      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log
+        "Determining if ${FUNCTION} exists with args ${TYPES} "
+        "passed with the following output:\n"
+        "${OUTPUT}\nFile ${SOURCEFILE}:\n"
+        "${CMAKE_CONFIGURABLE_FILE_CONTENT}\n")
+    ELSE(${VARIABLE})
+      MESSAGE(STATUS "Looking for ${FUNCTION} ${TYPES} - not found.")
+      SET(${VARIABLE} "" CACHE INTERNAL "Have function ${FUNCTION} ${TYPES}")
+      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log
+        "Determining if ${FUNCTION} exists with args ${TYPES} "
+        "failed with the following output:\n"
+        "${OUTPUT}\nFile ${SOURCEFILE}:\n"
+        "${CMAKE_CONFIGURABLE_FILE_CONTENT}\n")
+    ENDIF(${VARIABLE})
+  ENDIF("${VARIABLE}" MATCHES "^${VARIABLE}$")
+ENDMACRO(_CHECK_CXX_FUNCTION_EXISTS)
diff --git a/Common/Core/CMakeLists.txt b/Common/Core/CMakeLists.txt
index a49c7f1..9fc4655 100644
--- a/Common/Core/CMakeLists.txt
+++ b/Common/Core/CMakeLists.txt
@@ -311,13 +311,14 @@ foreach(t Int8 Int16 Int32 Int64 UInt8 UInt16 UInt32 UInt64 Float32 Float64)
 endforeach()

 # look for various headers and functions
+include(CheckCXXFunctionExists)
 include(CheckSymbolExists)
 include(CheckIncludeFile)

 # Check C++ <cmath> first, where the C++11 standard says these must be.
-check_symbol_exists(std::isnan "cmath" VTK_HAS_STD_ISNAN)
-check_symbol_exists(std::isinf "cmath" VTK_HAS_STD_ISINF)
-check_symbol_exists(std::isfinite "cmath" VTK_HAS_STD_ISFINITE)
+check_cxx_function_exists(std::isnan double "cmath" VTK_HAS_STD_ISNAN)
+check_cxx_function_exists(std::isinf double "cmath" VTK_HAS_STD_ISINF)
+check_cxx_function_exists(std::isfinite double "cmath" VTK_HAS_STD_ISFINITE)

 # Check C99 <math.h> next, where the C99 standard says these must be.
 # (they will be found even if they are defined as macros)
diff --git a/Common/Core/vtkMath.h b/Common/Core/vtkMath.h
index 36893f9..70a7b58 100644
--- a/Common/Core/vtkMath.h
+++ b/Common/Core/vtkMath.h
@@ -1245,8 +1245,11 @@ inline double vtkMath::ClampAndNormalizeValue(double value,
 #define VTK_MATH_ISINF_IS_INLINE
 inline int vtkMath::IsInf(double x)
 {
-  using namespace std; // Could be isinf() or std::isinf()
+#if defined(VTK_HAS_STD_ISINF)
+  return std::isinf(x);
+#else
   return (isinf(x) != 0); // Force conversion to bool
+#endif
 }
 #endif

@@ -1255,8 +1258,11 @@ inline int vtkMath::IsInf(double x)
 #define VTK_MATH_ISNAN_IS_INLINE
 inline int vtkMath::IsNan(double x)
 {
-  using namespace std; // Could be isnan() or std::isnan()
+#if defined(VTK_HAS_STD_ISNAN)
+  return std::isnan(x);
+#else
   return (isnan(x) != 0); // Force conversion to bool
+#endif
 }
 #endif

@@ -1265,8 +1271,9 @@ inline int vtkMath::IsNan(double x)
 #define VTK_MATH_ISFINITE_IS_INLINE
 inline bool vtkMath::IsFinite(double x)
 {
-#if defined(VTK_HAS_ISFINITE) || defined(VTK_HAS_STD_ISFINITE)
-  using namespace std; // Could be isfinite() or std::isfinite()
+#if defined(VTK_HAS_STD_ISFINITE)
+  return (std::isfinite(x) != 0); // Force conversion to bool
+#elif defined(VTK_HAS_ISFINITE)
   return (isfinite(x) != 0); // Force conversion to bool
 #else
   return (finite(x) != 0); // Force conversion to bool
--
1.7.4.1
